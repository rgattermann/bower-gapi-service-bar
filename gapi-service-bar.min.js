/*global angular,console*/
(function () {
    'use strict';

    // Module dependencies injection
    angular.module('gapiServiceBar', [ 'aruba.js', 'ngMaterial', 'datetime' ]);

}());

/*global angular */
(function () {
    'use strict';

    angular.module('gapiServiceBar').config(['$httpProvider', function ($httpProvider) {

        // Interceptor that add token in each Header Request
        $httpProvider.interceptors.push('gapiServiceBarRequestInterceptor');

    }]);

}());
/*jslint nomen:true*/
/*global console, angular, alert*/

(function () {
    "use strict";

    function GapiServiceBarController($scope, $rootScope, gapiServiceBarFactory, $timeout, datetime) {

        $scope.notifications = [];

        /* $scope Functions */
        $scope.userPanel = function () {
            console.log('UserPanel');
        };

        $scope.userSettings = function () {
            console.log('UserSettings');
        };

        $scope.userHelp = function () {
            console.log('userHelp');
        };

        $scope.openTicket = function () {
            console.log('openTicket');
        };

        $scope.logout = function () {
            gapiServiceBarFactory.logout();
        };

        $scope.redirect = function (url) {
            gapiServiceBarFactory.redirect(url);
        };

        $scope.getCallbackUrl = function (app) {

            $rootScope.$emit('GAPI-SERVICE-BAR-ISLOADING', true);

            gapiServiceBarFactory.getCallbackUrl(app._id, function (err, callbackUrl) {
                if (err) {
                    console.log('[ERROR]: ', err);
                }

                $rootScope.$emit('GAPI-SERVICE-BAR-ISLOADING', false);
                $scope.redirect(callbackUrl);
            });
        };

        $scope.reconnectWebsocket = function () {
            $rootScope.isWebsocketLoading = false;
            $rootScope.isWebsocketConnected = true;
            gapiServiceBarFactory.getNotifications();
        };

        $scope.markAsRead = function (notification, isMarkAll) {

            if (notification && Array.isArray(notification.arrayIds)) {
                $scope.notifications.map(function (item) {
                    notification.arrayIds.map(function (id) {
                        if (id === item._id) {
                            item.read = true;
                        }
                    });
                });
            } else {

                if (isMarkAll) {
                    var arrayids = [];

                    $scope.notifications.map(function (item) {
                        if (item.read === false) {
                            arrayids.push(item._id.toString());
                        }
                    });

                    gapiServiceBarFactory.setAsRead({
                        arrayRemindersId: arrayids,
                        markAllAsRead: true
                    });

                } else {

                    $scope.notifications.map(function (n) {
                        if (notification._id === n._id) {
                            if (!notification.savedOnServer) {
                                gapiServiceBarFactory.setAsRead({ 'reminder_id': notification._id });
                            } else {
                                n.read = true;
                            }
                        }
                    });
                }
            }

            // notifications counter
            $scope.getUnreadNotifications();
        };

        $scope.getUnreadNotifications = function () {
            var count = 0;
            $scope.notifications.map(function (item) {
                if (item.read === false) {
                    count += 1;
                }
            });

            $scope.unreadNotificationsCount = count;
        };

        function parseNotificationsDatetime() {
            var parser = datetime("dd-MM-yyyy HH:mm");
            $scope.notifications.map(function (n) {
                parser.setDate(new Date(n.doc.date));
                $timeout(function () {
                    n.doc.date = parser.getText();
                });
            });
        }

        (function () {
            try {

                $rootScope.$emit('GAPI-SERVICE-BAR-ISLOADING', true);

                $rootScope.$on('GAPI-SERVICE-BAR-NOTIFICATION', function (ev, notificationData) {

                    if (ev && notificationData) {

                        if (notificationData.markedAsRead) {
                            $scope.markAsRead({
                                _id: notificationData.reminder_id,
                                savedOnServer: true
                            });

                            return;
                        }

                        if (notificationData.markAllAsRead) {
                            $scope.markAsRead({
                                arrayIds: notificationData.arrayRemindersId,
                                savedOnServer: true
                            });

                            return;
                        }

                        $timeout(function () {

                            $scope.isNotificationAdded = true;

                            if (notificationData.length > 1) {

                                $scope.notifications = notificationData;

                                // Timeout necessary to perform bell animation
                                $timeout(function () {
                                    $scope.isNotificationAdded = false;
                                }, 1500);
                            } else {
                                $scope.notifications.push(notificationData[0]);

                                // Timeout necessary to perform bell animation
                                $timeout(function () {
                                    $scope.isNotificationAdded = false;
                                }, 1500);
                            }


                            // will format each notification datetime
                            parseNotificationsDatetime();

                            // notifications counter
                            $scope.getUnreadNotifications();

                        });

                    }
                });

                // If the user is not logged will be redirected to accounts
                gapiServiceBarFactory.validateUser().then(function () {

                    // Service Bar User (will get from aruba.js)
                    $scope.user = gapiServiceBarFactory.getUser();

                    // Service Bar Applications
                    $scope.applications = gapiServiceBarFactory.getApplications();

                    // Websocket notifications start
                    gapiServiceBarFactory.getNotifications();

                    // Service Bar Messages
                    $scope.messages = gapiServiceBarFactory.getMessages();

                    $rootScope.$emit('GAPI-SERVICE-BAR-ISLOADING', false);

                });
            } catch (error) {
                console.log('Error validatiing User: ', error);
                $rootScope.$emit('GAPI-SERVICE-BAR-ISLOADING', false);
            }
        }());

    }

    GapiServiceBarController.$inject = ['$scope', '$rootScope', 'gapiServiceBarFactory', '$timeout', 'datetime'];

    angular.module('gapiServiceBar').controller('GapiServiceBarController', GapiServiceBarController);

}());
/*global angular, console, document, $*/

function GapiServiceBarDirective() {
    "use strict";

    return {
        restrict: 'E',
        templateUrl: '../vendor/gapi-service-bar/gapi-service-bar.html',
        controller: 'GapiServiceBarController',

        link: function (scope) {
            scope.openMenu = function ($mdOpenMenu, ev) {
                $mdOpenMenu(ev);
            };
        }
    };
}

angular.module('gapiServiceBar').directive('gapiServiceBar', ['$mdDialog', GapiServiceBarDirective]);
/*global angular, console, FormData, window, WebSocket*/
/*jslint todo: true */

(function () {
    "use strict";

    var factory;

    function GapiServiceBarFactory($http, $q, $window, $rootScope, core, websocketFactory) {

        factory = {

            validateUser: function () {

                // Creating Promise
                var tokenDefer = $q.defer(),
                    token;

                // Checking if it comes from accounts with querystring token
                if (window.location.search.indexOf('token=') === 1) {

                    // Will set token to localStorage
                    this.setToken(window.location.search.split('=')[1]);

                } else {

                    // If there's no token will redirect to accounts to get a new one
                    token = this.getToken();

                    if (!token) {
                        $window.location.href = this.getAccountsUrl() + '?callbackurl=' + window.location.href;
                        tokenDefer.reject();
                    }
                }

                // Validating Token against Core Server
                this.validateToken(function (err, userdata) {

                    if (err || !userdata) {

                        tokenDefer.reject(err || 'No Data - check server availability');

                    } else {

                        // Setting User Data
                        var userObj = {
                            id       : userdata.id,
                            username : userdata.username,
                            imageUrl : userdata.imageUrl
                        };

                        // Storing it on Session Storage
                        $window.localStorage.setItem('GAPI-USER', JSON.stringify(userObj));

                        // Setting User Applications
                        $window.localStorage.setItem('GAPI-APPS', JSON.stringify(userdata.apps));

                        // Resolving Promise
                        tokenDefer.resolve();
                    }
                });

                return tokenDefer.promise;
            },

            validateToken: function (cb) {
                $http.get(core.getAccountsCoreUrl() + 'me')
                    .success(function (data) {
                        cb(null, data);
                    })
                    .error(function (err) {
                        console.log('[ERROR - validateToken]: ', err);
                        cb(err, null);
                    });
            },

            setToken: function (token) {
                if (token && token !== 'undefined' && token !== 'null') {
                    $window.localStorage.setItem('GAPI-TOKEN', token);
                }
            },

            getToken: function () {

                return $window.localStorage.getItem('GAPI-TOKEN');
            },

            logout: function () {

                $http.get(core.getAccountsCoreUrl() + 'logout')
                    .success(function () {

                        // Local Storage clean up
                        $window.localStorage.removeItem('GAPI-USER');
                        $window.localStorage.removeItem('GAPI-TOKEN');
                        $window.localStorage.removeItem('GAPI-APPS');

                        // Promise Resolve
                        $rootScope.$broadcast('GAPI-SERVICE-BAR-LOGOUT');
                    })
                    .error(function (err) {
                        $rootScope.$broadcast('GAPI-SERVICE-BAR-LOGOUT', {
                            "error: ": err
                        });
                    });
            },

            getUser: function () {
                var localGapiUser = $window.localStorage.getItem('GAPI-USER');
                return JSON.parse(localGapiUser);
            },

            getApplications: function () {
                var localGapiApps = JSON.parse($window.localStorage.getItem('GAPI-APPS'));
                return localGapiApps || [];
            },

            // It will connects the websocket and wait for pushs on {GAPI-SERVICE-BAR-NOTIFICATION} $broadcast
            // it also has reconnect capability
            getNotifications: function () {
                websocketFactory.connect();
            },

            setAsRead: function (reminder_id) {
                websocketFactory.setAsRead(reminder_id);
            },

            getMessages: function () {
                return [];
            },

            getAccountsUrl: function () {
                return core.getAccountsUrl();
            },

            redirect: function (url) {
                $window.location.href = url;
            },

            getCallbackUrl: function (appid, cb) {
                $http.post(core.getAccountsCoreUrl() + '_oauth', {
                    "appid": appid
                })
                    .success(function (data) {
                        if (data.callbackUrl) {
                            cb(null, data.callbackUrl + '?token=' + factory.getToken());
                        } else {
                            cb('CallbackUrl not found');
                        }
                    })
                    .error(function (err) {
                        console.log('[ERROR - validateToken]: ', err);
                        cb(err || 'Server Unavailable', null);
                    });
            }
        };

        return factory;

    }

    GapiServiceBarFactory.$inject = ['$http', '$q', '$window', '$rootScope', 'coreApiService', 'websocketFactory'];

    angular.module('gapiServiceBar').factory('gapiServiceBarFactory', GapiServiceBarFactory);

}());
/*global angular, console, FormData, window, WebSocket*/
/*jslint todo: true */

(function () {
    "use strict";

    var factory, ws, currentToken;

    function GapiServiceBarWebsocketFactory($rootScope, $window, $timeout, core) {

        factory = {

            connect: function () {


                if ($rootScope.websocket) {
                    return;
                }

                $rootScope.isWebsocketLoading = true;
                $rootScope.isWebsocketConnected = false;

                currentToken = $window.localStorage.getItem('GAPI-TOKEN');
                ws = new WebSocket(core.getAppCoreUrl().replace('http', 'ws').split("/api")[0] + '?token=' + currentToken);

                // When gets connected
                ws.onopen = function (ev) {
                    $timeout(function () {
                        console.log('WebSocket connected type: [' + ev.type + ']');
                        $window.localStorage.removeItem('GAPI-WEBSOCKET-RECONNECT');
                        $rootScope.isWebsocketConnected = true;
                        $rootScope.isWebsocketLoading = false;
                    });
                };

                // When the connection gets closed
                // Firstly it will try to reconnect after 30s
                // On a second shot it will try to reconnect after 60s
                ws.onclose = function () {

                    var isSecondShot = !!$window.sessionStorage.getItem('GAPI-WEBSOCKET-RECONNECT');

                    console.log('WebSocket disconnected, to reconnect click on the bell at the top bar and click on reconnect.');

                    if (!isSecondShot) {
                        $window.sessionStorage.setItem('GAPI-WEBSOCKET-RECONNECT', true);
                    } else {
                        $window.sessionStorage.removeItem('GAPI-WEBSOCKET-RECONNECT');
                    }

                    $timeout(function () {
                        $rootScope.isWebsocketConnected = false;
                        $rootScope.websocket            = null;
                    });

                    $timeout(function () {
                        factory.connect();
                    }, isSecondShot ? 60000 : 30000);
                };

                // Error handling
                ws.onerror = function (err) {
                    $rootScope.isWebsocketConnected = $rootScope.isWebsocketLoading = false;
                    $rootScope.websocket            = null;
                    console.log('WebSocket Error [' + JSON.stringify(err) + ']');
                };

                // When a message comes
                ws.onmessage = function (message) {
                    if (message.data) {
                        $rootScope.$broadcast('GAPI-SERVICE-BAR-NOTIFICATION', JSON.parse(message.data));
                    }
                };

                $rootScope.websocket = ws;

            },

            setAsRead: function (reminder_id) {
                if (!$rootScope.websocket || !reminder_id) {
                    return;
                }

                $rootScope.websocket.send(JSON.stringify(reminder_id));
            }
        };

        return factory;

    }

    GapiServiceBarWebsocketFactory.$inject = ['$rootScope', '$window', '$timeout', 'coreApiService'];

    angular.module('gapiServiceBar').factory('websocketFactory', GapiServiceBarWebsocketFactory);

}());
/*global angular, console*/
(function () {
    "use strict";

    function GapiServiceBarRequestInterceptor($q, $window) {

        return {

            // On request success
            request: function (config) {

                // Add Token info to every request
                config.headers.Authorization = $window.localStorage.getItem('GAPI-TOKEN');

                return config;
            },

            // On request error
            requestError: function (reason) {
                // Return the promise error reason.
                return $q.reject(reason);
            },

            // On response success
            response: function (response) {
                // Return the response or promise.
                return response || $q.when(response);
            },

            // On response error
            responseError: function (reason) {
                // Return the promise error reason.
                return $q.reject(reason);
            }

        };
    }

    GapiServiceBarRequestInterceptor.$inject = [ '$q', '$window' ];

    angular.module('gapiServiceBar').factory('gapiServiceBarRequestInterceptor', GapiServiceBarRequestInterceptor);

}());

//# sourceMappingURL=gapi-service-bar.min.js.map